\documentclass[]{article}
\usepackage[all]{xy}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{indentfirst}
\usepackage{hhline}
\usepackage{listings}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{tipa}
\usetikzlibrary{arrows,automata}
\begin{document}

\newtheorem{thm}{Theorem}
\title{COMS W3261 \\ Computer Science Theory \\ Homework \#4}
\author{Alexander Roth}
\date{2014 -- 11 -- 12}
\maketitle

\section*{Problems}
\begin{enumerate}
\item Classify each of the following languages as being (i) recursive, (ii)
recursively enumerable but not recursive, or (iii) not recursively enumerable.
In each case briefly justify your answer.
\begin{enumerate}
\item $\{\,D\,|\,D$ is a deterministic finite automaton that accepts at least
one string with an equal number of $a$'s and $b$'s$\,\}$.
\item[\emph{Solution}:] This language is recursive. We can simulate a DFA $D$
that accepts at least one string with an equal number of $a$'s and $b$'s, and we
can create a Turing machine $M$ that simulates this DFA. Thus, $M$ will always
halt whenever $D$ halts, which occurs either when it accepts the string or
rejects said string.

\item $\{\,(D_1,D_2)\,|\,D_1$ and $D_2$ are deterministic finite automata and
$L(D_1) = L(D_2)\,\}$
\item[\emph{Solution}:] This language is recursive. We can construct a Turing
machine $M$ that simulates the table-filling algorithm that determines if two
DFA's are equivalent. Thus, we can check for equivalence between $D_1$ and
$D_2$; if we find that $L(D_1) = L(D_2)$, $M$ will halt and accept, otherwise it
will halt without accepting.

\item $\{\,(M,w)\,|\,M$ is a Turing machine that halts on input $w\,\}$.
\item[\emph{Solution}:] This language is recursively enumerable. We can
construct a Turing machine $Q$ that simulates the Turing machine $M$. Thus, we
can simulate $M$ on $Q$. However, we do not know if $M$ will ever halt; thus,
$Q$ may never halt unless $M$ halts and accepts. Therefore, it is recursively
enumerable.

\item $\{\,(M_1,M_2)\,|\,M_1$ and $M_2$ are Turing machines and $L(M_1) =
L(M_2)\,\}$
\item[\emph{Solution}:] Not Recursively enumerable or Recursively Enumerable

\end{enumerate}

\item Boolean expressions
\begin{enumerate}
\item Describe an algorithm in high-level pseudocode to evaluate a boolean
expression given a truth assignment to its variables. Describe how your
algorithm evaluates the boolean expression $x \vee \neg(y \wedge z)$ for the
truth assignment $T(x) = 0$, $T(y) = 0$, $T(z) = 1$. (1 is true, 0 is false)
\item[\emph{Solution}:] We can construct a parse tree where the leafs of the
tree are all literals of the boolean expression, and any negation we have found
on the way gets pushed down to the literals. From there, we can traverse up the
tree, evaluating the truth values as we go. Once we reach the top of the tree,
we have figured out the truth values for the whole boolean expression.

We can construct a parse tree for $x \vee \neg(y \wedge z)$ as follows: \\
\Tree [.$\vee$ [.$x$ ] [.$\vee$ [.$\overline{y}$ ] [.$\overline{z}$ ] ] ] \\
Now, we read up the tree. Thus, $(\overline{y} \vee \overline{z})$ becomes $(1
\vee 0)$, which evaluates to $1$. From there, we have $(x \vee 1)$, which is
true.

\item What is the time complexity of your algorithm?
\item[\emph{Solution}:]

\item Describe an algorithm in high-level pseudocode to determine whether a
boolean expression always evaluates to true on all truth assignments to its
variables (is a tautology). Illustrate how your algorithm performs on the
boolean expression $x \vee \neg (y \wedge x)$.
\item[\emph{Solution}:]

\item What is the time complexity of your algorithm?
\item[\emph{Solution}:] The time complexity to build the parse tree

\end{enumerate}

\item The game PEBBLES is played on an $k \times n$ chessboard. Initially each
square of the chessboard has a black pebble, or a white pebble, or no pebble.
You play the game by removing pebbles one at a time. You win the game if you can
end up with a board in which each column contains only pebbles of a single color
and each row contains at least one pebble.
\begin{enumerate}
\item Show that the set of winnable PEBBLES game is in NP. Hint: Describe a
nondeterministic polynomial-time algorithm to  determine whether a given PEBBLES
board is winnable.
\item[\emph{Solution}:]

\item Given a boolean expression $E$ in 3-CNF with $k$ clauses and $n$
variables, construct the following $k \times n$ board: If literal $x_i$ is in
clause $c_j$, put a black pebble in column $x_i$, row $c_j$. If literal $\neg
x_i$ is in clause $c_j$, put a white pebble in column $x_i$, row $c_j$. Show
that $E$ is satisfiable if and only if this PEBBLES game is winnable.
\item[\emph{Solution}:]

\item What can you conclude from showing (a) and (b)?
\item[\emph{Solution}:]
\end{enumerate}

\item A polynomial-time verifier for a language $L$ is an algorithm $V$ such
that $L = \{\,w\,|\,V$ accepts $(w,c)$ in polynomial time for some
polynomial-length string $c$ called a certificate or proof of membership in
$L\,\}$. Show that NP is equivalent to the class of languages that have
polynomial-time verifiers.
\item[\emph{Solution}:]

\item The classes P and NP
\begin{enumerate}
\item Show that if language $A$ is NP-complete and $A$ is in P, then P=NP.
\item[\emph{Solution}:] Suppose $A$ is both NP-complete and in $P$. Then all
languages $L$ is $\mathcal{NP}$ reduces in polynomial-time to $A$.

\item Show that if $A$ is NP-complete and $A$ is polynomially reducible to a
language $B$ in NP, then $B$ is NP-complete.
\item[\emph{Solution}:] We need to show that every language $L$ in
$\mathcal{NP}$ polynomial-time reduces to $B$. We know that there is a
polynomial-time reduction of $L$ to $A$, since $A$ is already NP-complete. Thus,
a string $w$ in $L$ of length $N$ is converted to a string $x$ in $A$ of length
at most $p(n)$ where $p(n)$ is the polynomial time reduction.

We know that there is a polynomial-time reduction of $A$ to $B$; this reduction
takes polynomial time $q(m)$. This reduction transforms $x$ to some string $y$
in $B$, taking time at most $q(p(n))$. Thus, the transformation of $w$ to $y$
takes time at most $p(n) + q(p(n))$, which is a polynomial. Therefore, $L$ is
polynomial-time reducible to $B$. Since $L$ could be any language in
$\mathcal{NP}$, we know that all of $\mathcal{NP}$ polynomial-time reduces to
$B$; thus, $B$ is NP-complete.

\end{enumerate}
\end{enumerate}

\end{document}
